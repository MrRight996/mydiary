## JVM探索

- 探探你对JVM的理解？java8虚拟机和之前的变化？

- java-->class-JVM

- 什么是OOM,什么是栈溢出stackoverflowerror？怎么分析？

- JVM的常用调优参数？

- 内存快照如何抓取，怎么分析Dump文件？

- 探探JVM中类加载器你的认识？rt-jar 

  

  1. ## JVM的位置

     ![image-20210313142914477](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210313142914477.png)

  2. ## JVM的体系结构

     ![](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210313145141677.png)

  3. ## 类加载器

     作用：加载Class文件~ new student(); 引用放在栈里面 具体的东西放在堆里面

     ![image-20210313151054913](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210313151054913.png)

     1.虚拟机自带的加载器

     2.启动类（根）加载器

     3.扩展类加载器

     4.应用程序类加载器

  4. ## 双亲委派机制

     看百度 父类的加载器优先使用否则再使用子类的

     APP-->EXC--BOOTSTRAP

  5. ## 沙箱安全机制	

     沙箱就是限制程序运行的环境。

     字节码校验码（bytecode verifier）：确保java类文件遵循java语言规范。这样可以

     

  6. ## Native

  7. ## PC寄存器

  8. ## 方法区

     

  9. ## 栈

     程序=数据结构+算法：持续学习~

     程序=框架+业务逻辑：吃饭~

     栈：栈内存，主管程序的运行，生命周期和线程同步；

     线程结束，占内存也就是释放，对于栈来说，不存在垃圾回首问题

     一旦线程结束，栈就over！

     栈：8大基本类型+对象引用+实例的方法

     栈运行原理：栈帧

     程序正在执行的方法，一定在栈顶。

     

  10. ## 三种jvm

      

      - Sun公司的 HotSpot
      - BEA JRockt
      - IBM J9vm 

  11. ## 堆

      Heap,一个JVM只有一个堆内存，堆内存的大小是可以调节的。

      类加载器读取了类文件后，一般会把什么东西放到堆中？

      类的具体实例 类的常量 类的方法 类的变量 保持我们所有引用类型的真实对象

      堆内存中还要细分为三个区域：

      - 新生区

      - 幸存区

      - 永久区

        ![image-20210317220417273](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210317220417273.png)

        GC垃圾回收，主要是在伊甸园区和养老区

        假设内存满了，OOM，堆内存不够！

        在JDK8之后，有永久存储区改了个名字，元空间

  12. ## 新生区、老年区

      - 类的对象：诞生和成长的地方，甚至死亡；
      - 伊甸园区，所有的的对象都是在伊甸园区new出来的
      - 幸存者0区和1区
      - 真理：经过研究，有98%的对象都是临时对象！

  13. ## 永久区

      这个区域常驻内存的/同来存放JDK自身携带的class对象。interface元数据，存储的是Java运行时的一些环境或类信息~，这个区域不存在垃圾回收！关闭虚拟就会释放这个区域的内存~

      一个启动类，加载了大量的jar包。tomcat部署了太多的应用，大量动态生成的反射类。不断地被加载。知道内存满，就会出现OOM

      - jdk1.6之前：永久代
      - jdk1.7：永久代，但是慢慢退化了，去永久代，常量池在堆中
      - jdk1.8之后：无永久代，常量池在元空间

      元空间逻辑上存在，物理上不存在

      在一个项目中，突然出现了OOM故障，那么该如何排除~研究为什么出错~

      - 能够看到代码第几行出错：内存快照分析工具，MAT，Jprofiler

      - Debug，一行行分析代码

        MAT，Jprofiler作用：

        - 分析Dump内存文件，快速定位内存泄露；
  
        - 获得堆中的数据
  
        - 获得大的对象
  
  14. 堆内存调优
  
  15. GC 垃圾回收器
  
      JVM在进行GC时，并不是对这三个区域统一回收，大部分的时候，回收都是新生代~
  
      - 新生代
  
      - 幸存区（from，to）
  
      - 老年区
  
      GC两种类：轻GC（普通的GC），重GC（全局GC）
  
      题目：
  
      - JVM的内存模型和分区~详细到每个区放什么？
      - 堆里面的分区有哪些？Eden，from，to，老年区，说说他们的特点！
      - GC的算法有哪些？标记清除法，标记整理法，复制算法，分代收集算法，怎么用的
      - 轻GC和重GC分别在什么时候发生？
  
      复制算法，谁空谁是to
  
      ![image-20210318221450171](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210318221450171.png)
  
      - 好处：没有内存的碎片
  
      - 坏处：浪费多一半的内存空间。多了一半空间永远是to，假设对象100%存货（极端情况）
  
        
  
      复制算法最佳使用场景：对象存活度较低的时候；新生区~
  
      ​	标记清除法
  
      对需要清除的对象进行标记
  
      对有标记的对象进行清楚
  
      优点：不需要额外的空间
  
      缺点：两次扫描，严重浪费时间，会产生内存碎片
  
      
  
      **标记压缩**
  
      压缩：防止内存碎片，再次扫描，向一段移动存活的对象，多了一个移动成本
  
      
  
  16. 常用算法
  
  17. JMM
  
      
  
      1、什么是JMM？
  
      java memory model
  
      2、它干嘛的？
  
      作用：缓存一致性协议，用于定义数据读写的规则（遵守，找到这个规则）
  
      解决共享对象可见性这个问题：volitate
  
      内存交互操作有8种，虚拟机实现必须保证每一个操作都是原子的，不可在分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外）
  
      - lock   （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态
      - unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
      - read  （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
      - load   （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中
      - use   （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令
      - assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中
      - store  （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用
      - write 　（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中
  
      　　JMM对这八种指令的使用，制定了如下规则：
  
      - 不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write
      - 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存
      - 不允许一个线程将没有assign的数据从工作内存同步回主内存
      - 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作
      - 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁
      - 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值
      - 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量
      - 对一个变量进行unlock操作之前，必须把此变量同步回主内存
  
      　　JMM对这八种操作规则和对[volatile的一些特殊规则](https://www.cnblogs.com/null-qige/p/8569131.html)就能确定哪里操作是线程安全，哪些操作是线程不安全的了。但是这些规则实在复杂，很难在实践中直接分析。所以一般我们也不会通过上述规则进行分析。更多的时候，使用java的happen-before规则来进行分析。
  
      
  
  18. 总结
  
      内存效率：复制算法>标记清除算法>标记压缩算法（时间复杂度）
  
      内存整齐度：复制算法=标记压缩算法>标记清除算法
  
      内存利用率：标记压缩算法=标记清除算法>复制算法
  
  思考一个问题：难道没有最优算法吗？
  
  没有，没有最好的算法，只有最合适的算法
  
  年轻代：
  
  - 存活率低
  
  - 复制算法！
  
  老年代：
  
  - 区域大：存活率
  - 标记清除（内存碎片不是太多）+标记压缩混合实现

​	1.百度

​	2.思维导图

 单点登录~|SSO

学习新东西是常态：

- netty
- Spring Cloud Alibaba

面试：

3/10==pass，面经=10，分析这十个？触类旁通：百度面试题

通过大量的面试总结，得出一套解题思路

